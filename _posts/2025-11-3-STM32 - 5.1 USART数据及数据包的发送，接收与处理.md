---
date: 2025-09-16
tag: "#嵌入式"
layout: post
title: STM32 - USART数据及数据包的发送，接收与处理
---
#嵌入式 
# 初始化流程
1. 开启时钟
2. GPIO初始化
3. 配置USART
4. 配置中断
5. 使能

#### 常用库函数
```C
USART_DeInit(USARTx); //复位USART
USART_Init(USARTx , USART_InitStruct); //eee
USART_StructInit(...); //eee

USART_ClockInit(USARTx , USART_ClockInitStruct); //开启同步时钟，不常用
USART_ClockStructInit(USART_CLockInitStruct);

USART_Cmd(USARTx , NewState); //使能
USART_ITConfig(USARTx , USART_IT , NewState); //使能中断，这样才能输出中断

USART_SendData(USARTx ,uint16_t Data);
uint16_t USART_ReceiveData(USARTx );
```

#### 初始化
```C
RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);

AutoInitGPIO(GPIO_Mode_AF_PP); //我们用的是复用功能，用复用推挽
AutoInitGPIO(GPIO_Mode_AF_PP); //一个输入，一个输出

USART_InitTypeDef USART_InitStructure;
USART_InitStructure.USART_BaudRate = 9600; //波特率
USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None; //流控
USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx; //模式
USART_InitStructure.USART_Parity = USART_Parity_No; //校验
USART_InitStructure.USART_StopBits = USART_StopBits_1; //停止位
USART_InitStructure.USART_WordLength = USART_WordLength_8b;  //数据位
USART_Init(USART1 , &USART_InitStructure);

USART_Cmd(USART1 , ENABLE);
```

# 数据的发送
#### 一些函数
```C
void Serial_SendData(uint8_t Data){ //uint8_t 就是 char
	USART_SendData(USARTx, Data); //写操作的时候，标志位会被自动清零，所以这里不需要手动清理
	while(USART_GetFlagStatus(USARTx , USART_FLAG_TXE) == RESET); //判断标志位为1后再进行下一次传输
}

void Serial_SendString(uint8_t * String){ //字符串的发送
	for(int i = 0;String[i] != '\0';i++){
		Serial_SendData(String[i])
	}
}

void Serial_SendArray(uint8_t * Array , uint16_t Length){
	发送数组，略
}
//发送数字的代码略，得自己写一个pow函数
```

#### printf的移植
我们printf的标准输出是在cmd里，但是显然单片机没有cmd，所以我们要重定向到串口
显然，我们得重新定义一下stdio.h里的函数了

```C
int fputc(int ch, FILE *f){
	Seiral_SendByte(ch);
	return ch;
}
```

**printf**是通过不断调用**fputc**实现的，这里的重定向相当于printf的重定向

```C
printf("%d,666",666);
```

这样就可以直接输出内容了，不用上面乱七八糟的函数

**这里隆重介绍sprintf !!!**，实际上这在OJ里也是挺好用的，可以把格式化字符输出到一个字符串里

```C
char string[100];
sprintf(string , "...");
Serial_SendString(string);
```

**当然，我们也可以封装sprintf**

```C
#include <stdarg.h>
#include <stdio.h>
void Serial_Printf(char *format, ...){
	char String[100];
	va_list arg;
	va_start(arg, format);
	vsprintf(String , format , arg);
	va_end(arg);
	Serial_SendString(String);
}
```

这样直接用Serial_Printf就可以和Printf一样输出了

# 数据的接收
检查数据的接收有两种办法，一种是在主函数里循环判断标志位是否为1，一种是中断，这里直接用中断方法了

```C
USART_ITConfig(USART1 , USART_IT_RXNE , ENABLE);

NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);

NVIC初始化略
USART1_IRQn;

uint8_t Serial_RxData;
uint8_t Seria_RxFlag;

void USART1_IRQHandler(void){
	if(USART_GetITStatus(USARTx , USART_IT_RXNE) == SET){
		Serial_RxData = USART_ReceiveData(USART1);
		Serial_RxFlag = 1;
		USART_ClearITPendingBit(USART1 , USART_IT_RXNE);
	}
}

uint8_t Serial_GetRxFlag(void){
	if(Serial_RxFlag == 1){
		Serial_RxFlag = 0;
		return 1;
	}
	return 0;
}

uint8_t Serial_GetRxData(void){
	return Serial_RxData;
}
```

# 数据包概述 / 发送、接收与处理
**数据包**类似于一个信，里面装着一堆数据，方便后续处理，其包含以下几个内容

| 数据包组成部分     | 说明                              |
| ----------- | ------------------------------- |
| **帧头**      | 数据包的开始标志，用于接收方识别一个新数据包的开始。      |
| **设备地址/ID** | 在多设备通信中，用于区分数据包是发给哪个设备的。        |
| **数据长度**    | 指明后面跟着的有效数据有多少个字节，防止接收多或少。      |
| **命令/指令字**  | 告诉接收方这个数据包是干什么的（例如：读取温度、控制继电器）。 |
| **有效数据**    | 实际要传输的信息（例如：温度值、开关状态）。          |
| **校验和/CRC** | 用于验证数据在传输过程中是否出错（如比特跳变、丢失）。     |
| **帧尾**      | 数据包的结束标志。                       |
接收端通过处理**数据包的数据**来执行相应的操作
当然，上面不用全都有。  

#### 数据包发送
这里我们以 **$** 为包头, **@** 为包尾

```C
//发送数据数字包
Serial_SendData('$');
Serial_SendArray(...);
Serial_SendData('#');

//发送文本数字包
Serial_SendData('$');
Serial_SendString(...);
Serial_SendData('#');
```

#### 数据包的接收和处理
这是数据包收发的难点，我们采用**状态机**

![[STM32 定长包发送状态机流程图.png]]

接下来我们来进行实际的代码实现，假设包定长为4

```C
uint8_t Serial_RxPacket[4];
uint8_t Serial_TxPacket[4];

void Serial_SendPacket(void){
	Serial_SendData('$');
	Serial_SendArray(Serial_TxPacket);
	Serial_SendData('$');
}

uint8_t Serial_GetRxFlag(void){
	if(Serial_RxFlag == 1){
		Serial_RxFlag = 0;
		return 1;
	}
	return 0;
}

void USART1_IRQHandler(void){
	static uint8_t Rx_State = 0; //静态变量见Python的OOP教程
	static uint8_t index = 0;
	if(USART_GetITStatus(USART1 , USART_IT_RXNE) == SET){
		uint8_t RxData = USART_ReceiveData(USART1);
		
		if(Rx_State == 0){ //等待包头
			if(Rx_Data == '$'){
				Rx_State = 1;
				index = 0;
			}
		}else if(Rx_State == 1){ //读取数据
			Serial_RxPacket[index] = RxData;
			index ++;
			if(index >= 4){
				Rx_State = 2;
			}
		}else if(Rx_State == 2){ //等待包尾
			if(RxData == '@'){
				Rx_State = 0;
				Serial_RxFlag = 1;
			}
		}
		USART_ClearITPendingBit(USART1, USART_IT_RXNE);
	}
}

//主函数
int main(void){
	if(Serial_GetRxFlag() == 1){
		...  
	}
}

```

其他的函数判断略