---
date: 2025-09-16
tag: "#嵌入式"
layout: post
title: STM32 - TIM编码器接口
---
#嵌入式 
在先前，旋转编码器是利用**外部中断**来计次的，这**占用了两个通道**，非常累赘
有了编码器接口就可以节省资源了

当然，这也可以用来测量**电机的速度**，结合**PID**就可以控制电机的转速了

# 编码器接口 Encoder Interface
**编码器接口**可接收增量（正交）编码器的信号，根据编码器旋转产生的**正交信号脉冲**，自动控制**CNT自增或自减**，从而指示编码器的位置、旋转方向和旋转速度
- 每个**高级定时器**和**通用定时器**都拥有1个编码器接口，配成这个模式就干不了其他活了
- 两个输入引脚借用了**输入捕获的通道1和通道2**
  
#### 正交信号
就是**触电式旋转编码器**产生的，两个波相位相差$90\degree$的方波信号

#### 软件资源 / 硬件资源
**软件资源**指的就是**中断**类资源，一般在CPU内处理
**硬件资源**指的就是**输入捕获**，**输出比较**这种，其实本质上也是可以用**软件资源**代替的：
- **输入捕获**本质是读取指定电平然后锁CNT到CCR，这我们在**TIM定时中断**里也可以完成
- **输出比较**本质是将CNT与CRR进行比较，这我们在**TIM定时中断**里手动判断，并对GPIO口置电平也可以完成 

**在[[STM32 通用计时器.png]]** 可以看到编码器是接了**TI1FP1和TI2FP2**两个引脚，所以是占用了TIM_CH1和TIM_CH2的，在检测正交信号的时候，这**两个接口都得用**。

即两个口的电平分别为**TI1和TI2**，我们一般在**TI1和TI2均进行计次**

![[STM32 正交信号计数图.png]]

# 编码器初始化
1. 开时钟
2. 配GPIO，输入模式
3. 配置时基单元
4. 配置输入捕获单元
5. 配置编码器接口模式
6. 使能计时器

**需要用到的库函数**
```C
TIM_EncoderInterfaceConfig(TIMx , EncoderMode , TIM_IC1Polarity , TIM_IC2Polarity);
```

#### 配置
```C
RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIMx,ENABLE); 
RCC_APB2PeriphClockCmd(RCC_APB2PeriphGPIOA,ENABLE);

AutoInitGPIO(...); //PA6 PA7
TIMx_Init(65536,1);

TIM_ICInitTypeDef TIM_ICInitStructure;
TIM_ICStructInit(&TIM_ICInitStructure); //编码器模式不需要全部配置，后面那些分频器啥的就不用配置了
TIM_ICInitStructure.TIM_Channel = TIM_Channel_1
TIM_ICInitStructure.TIM_ICFilter = 0xF;
TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;
TIM_ICInit(TIMx , &TIM_ICInitStructure);

TIM_ICStructInit(&TIM_ICInitStructure); //配置Channel2，两个都要去到编码器
TIM_ICInitStructure.TIM_Channel = TIM_Channel_2;
TIM_ICInitStructure.TIM_ICFilter = 0xF;
TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;
TIM_ICInit(TIMx , &TIM_ICInitStructure);

TIM_EncoderInterfaceConfig(TIMx , TIM_EncoderMode_TI12 , TIM_ICPolarity_Rising , TIM_ICPolarity_Rising);
//实际上这里配置的两个极性上面已经配置过了，这里属于重复配置
```

这样就配置好了，编码器会自动识别正交波并对Counter +1 -1，也就是说直接读取Counter就行了

```C
  TIM_GetCounter(TIMx);
```

如果需要负数，只需要把**uint**改成**int**就行了
如果要读取速度，则需要加一个**Temp**先存CNT的数据，再清零CNT，然后返回**Temp**
 



