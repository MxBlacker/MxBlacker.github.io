---
date: 2025-09-16
tag: "#嵌入式"
layout: post
title: STM32 - TIM中断概述
---
#嵌入式 
# TIM Timer
- **定时器**可以对输入的时钟计数，并在达到设定值时触发中断
	例如$72MHz$每秒输入$72M$次，每输入一次，内部的Counter就会++
	而我设定为Counter到达$72K$的时候，触发一次中断，这样一秒就会触发1000次中断
	也就是一次中断的间隔为$1ms$
	即:
$$
计时长度 = {1 \over {输入频率 \over 触发阈值}}s = {触发阈值 \over 输入频率}s
$$
- **定时器**具备定时中断功能，还能**选择输入的时钟源**，**输入捕获**，**输出比较**，**编码器接口**，**主从触发模式**等等
- 定时器分为**基本定时器**，**通用定时器**，**高级定时器**

TIM1，TIM8被规定位**高级计时器**
TIM6，TIM7被规定为**基本定时器**
TIM2~TIM5被规定为**通用计时器**

我们用的STM32有的资源是**TIM1~TIM4**

> [!attention]
> 高级定时器对速度有一定要求，所以总线连接在**APB2**上
> 通用计时器和基本定时器，则连接在**APB1**上，初始化时需要注意

## 时基单元
- 我们STM32采用的时**16位时基单元**，最大可以实现$59.65s$的定时
	其中包含**计数器 ( Counter ) , 预分频器 ( Prescaler ) , 自动重装寄存器 ( Auto Reload Register ARR )**，他们构成了最基础的时基单元，可以完成最基础的计时功能

#### 预分频器 Prescaler 
用于接受经过**触发控制器**后的时钟信号，他会将这种**方波型号**分频，可以理解为将信号的周期除以x
- 加入预分频器存的是1，那么输入什么就输出什么
- 加入预分频器存的是n，那么一秒输入$72MHz$，他就输出${72 \over n}MHz$

#### 计数器 Counter
用于接受来自预分频器的信号，来一次计数器就加一
同时你也可以配置其计数模式（基本计时器没有这个功能）
- 向上计数，从0开始计
- 向下计数，从阈值开始计
- 中央对其，先向上，后向下，一个周期变个方向

#### 自动重装寄存器 ARR
检测计数器的数值和自己存的数值，即**触发阈值**，一旦达到阈值，就**触发中断**，并清空Counter

每一个都是16位的寄存器，而默认输入频率位72MHz
所以:
$$
	\left(2^{16} \over \left({7.2\cdot10^6 \over 2^{16}}\right)\right)s \approx 59.65s
$$

## 基本定时器及其框图分析
基本定时器就只有单纯的计时并发送中断的功能，但其他定时器是建立在其基础上的
![[STM32 基本定时器框图.png]]

- 基本定时器只能读RCC的TIMxCLK，也就是那个**72MHz的时钟**
- 经过**触发控制器**来到**预分频器**，分频后的信号来到CNT，达到阈值后输出**UI（Update Interrupt）**，通往NVIC排队

下面那个U是更新事件，暂时不管

- **TRGO ( Trigger Out ) 触发输出**这里是通过定时器来触发DAC专门做的口，本来需要定时器触发中断，然后再在中断函数里触发DAC，但是太麻烦了，而且会频繁中断主程序，所以专门做了这个口

## 通用定时器及其框图分析
通用计时器能**选择输入的时钟源**，**输入捕获**，**输出比较**，**编码器接口**，**主从触发模式**等等
![[STM32 通用计时器.png]]

- 中间偏上的部分依然是**时基单元**
- 上半部分实现的功能是**内外时钟源选择**和**主从触发模式**

	**内部时钟**已经说了，是RCC的72MHz的
	**外部时钟**有
	-  **外部时钟模式2** : TIMx_ETR ( External ) / \_CH1~CH4 好像是PA0~PA4的复用功能
	- **外部时钟模式1** : TRGI ( Trigger in ) 触发输入，可以将另一个时钟调为更新事件输出，将事件**映射**到TRGO上( 这就是主模式输出的功能 )，然后将当前时钟作为TRGI输入，这样就可以时钟套时钟，达到延长计时的效果，这我们称之为**级联**。
		ETR时钟的信号好像也能走这一路，只不过如果走这一条路会占用TRGI通道。TIMx_CH1的上升沿下降沿也可以作为输入。TIMx_CH1，TIMx_CH2的引脚也可以作为输入。
		
- 右下是**输出比较**电路，四个通道对应四个引脚，可以输出PWM波形
	- **捕获/比较寄存器**，**CCR ( Capture / Compare Register )**，具体用法见[[STM32 - 4.2 TIM输出比较]]
- 左下时**输入捕获**电路，可以读取方波的频率
- 中下时输入输出时共用的寄存器

## 高级定时器及其框图分析
不多赘述，就加了一个重复次数计数器，就是可以实现每隔几个周期再中断一次
新增了死区生成电路，输出比较可以输出互补的方波了

# 定时中断流程图

![[STM32 定时中断流程图.png]]

# 预分频器时序

**CK_PSC**是输入频率
**CK_EN**是预分频器的开启状态
**CK_CNT**是预分频器输出频率

![[STM32 预分频器时序.png]]

由此可以看见，在周期中间改变寄存器里的分频值，其作用效果会在下一个周期启用

# 计数器时序

![[STM32 计数器时序图.png]]

有一个APRE参数
- APRE = 1时，若阈值在周期中被改变，则其作用效果会在下一周期启用
- APRE = 0时，若阈值在周期中被改变，则其作用效果立即生效

# RCC时钟树及其框图
外设都接在被称为**总线**的东西上，例如（AHB，APB1，APB2）
不同外设接在不同**总线**上，而像GPIO，ADC这种大部分都接在**APB2**上，**APB2是高速外设总线**!

而在使用外设前，我们需要**启动这条总线的时钟**
**所有的数字电路**（包括GPIO控制器）都需要一个**时钟信号来同步工作**。没有时钟，电路就无法执行任何操作，就像没有了心跳。

**时钟是所有外设运行的基础**，所以它总是最先需要配置好的东西
在主函数之前，还会执行一个**SystemInit**函数，这个函数就是用来配置时钟树的

![[STM32 RCC时钟树.png]]

- 左边是用来生成72MHz的，有**四个振荡源**，分别为
	- 内部8MHz高速RC振荡器
	- 外部4-16MHz高速石英晶体振荡器，即晶振
	以上这两个是用来**提供系统时钟**的，**AHB，APBx**都源于这两个
	- 外部32.768KHz低速晶振，**一般给RTC提供时钟**
	- 内部40KHz低速RC振荡器，**给看门狗用的**
**8MHz**被PLL倍环9倍后就成了**72MHz**

- CSS ( Clock Security System ) 用于检测时钟是否失效，防止程序卡死，这在高级定时器的死区电路那一块也有体现

- 通往**APB1**的线原先是经过预分频器（默认为2）变为**36MHz**，但是其支路指明了操作，又**翻倍回去**了，所以时钟依旧是**72MHz**，通向TIMXCLK

- **APB2**预分频器默认为1，故就是72MHz

- 可以看见APBx每一个与门下面都有一个**外设时钟使能**，这就是我们写**RCC_APBxPeriphClockCmd**作用的地方，由此也可见**Cmd**的意思就是**使能 ( Command )**

[[STM32 - 4.1 TIM中断的初始化和使用]]
[[STM32 - 4.2 TIM输出比较]]
[[STM32 - 4.1 EX 非阻塞式电路]]
[[STM32 - 4.3 TIM输入捕获]]
[[STM32 - 4.4 TIM编码器接口]]
[[STM32 - 5 USART串口协议]]