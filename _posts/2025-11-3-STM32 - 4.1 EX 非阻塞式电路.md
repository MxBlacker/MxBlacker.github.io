---
date: 2025-09-16
tag: "#嵌入式"
layout: post
title: STM32 - EX 非阻塞式电路
---
#嵌入式 
# 非阻塞式电路
在按钮的检测中，我们尝试了用EXTI来检测按钮是否按下，但效果极差，而且为了消抖而Delay的20ms会导致整个系统的阻塞，我们急需一个**非阻塞式电路**！

**非阻塞式电路**，也就是任意一个电路不会影响整体的运行，全程畅通无阻

回想Hyp家园，为了时刻检测玩家的数值，我们运用了一个中毒循环，每秒检测一次
这里我们用到的是TIM中断，这样也可以每**隔一段时间就检测一次**

同时，**用TIM来消除按钮的抖动**，也是非常好的选择，这样就避免了Delay造成的阻塞

## 定时中断函数的基本格式

```C
void TIM2_IRQHandler(void){
	if (TIM_GetITStatus(TIM2, TIM_IT_Update) != RESET)
    {
		LED_flow();
		button_check();
        TIM_ClearITPendingBit(TIM2, TIM_IT_Update);
    }
}
```

一定要记得清除标志位！

## LED函数示例

```C
void LED_flow(){
	
	LED_counter++;
	
	short speed_tier = get_value(MENU_LED,0);
	short dir = get_value(MENU_LED,1);
	
	int speed = 500;
	switch(speed_tier){
		case 0:
			speed = 500;
			break;
		case 1:
			speed = 1000;
			break;
		case 2:
			speed = 200;
			break;
	}
	
	if(LED_counter >= speed){
		LED_counter = 0;
		
		if(dir == 0) LED_lit_pin = (LED_lit_pin + 1) % 4;
		else LED_lit_pin = ((LED_lit_pin - 1) + 4) % 4;
		
		reset_LED();
		switch(LED_lit_pin){
			case 0:
				GPIO_ResetBits(GPIOB,GPIO_Pin_12);
				break;
			case 1:
				GPIO_ResetBits(GPIOB,GPIO_Pin_13);
				break;
			case 2:
				GPIO_ResetBits(GPIOB,GPIO_Pin_14);
				break;			
			case 3:
				GPIO_ResetBits(GPIOB,GPIO_Pin_15);
				break;
		}
		
	}
}
```

可以看到，这里我们用的是`LED_Counter`来计时，中断函数是1ms触发一次，这里的Counter也是1ms加1，这样就可以分别计时了