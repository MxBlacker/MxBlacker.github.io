---
date: 2025-09-16
tag: "#嵌入式"
layout: post
title: STM32 - EXTI的初始化和具体使用
---
#嵌入式 
比如传感器这类硬件，STM32总不能24小时去看他有没有接通
**所以EXTI检测到上升沿的时候再读取数据是最佳的选择！**

# GPIO -> AFIO -> EXTI -> NVIC的初始化
**基本思路**
1. 依旧是配置RCC和GPIO，并选择**输入模式**
2. 配置AFIO
3. 配置EXTI，选择中断触发方式和响应方式
4. 配置NVIC，配置优先级
5. CPU接收到中断信号，根据中断号，去**中断向量表**找函数名，执行中断函数

#### RCC时钟配置
```C
RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
```

#### AFIO时钟配置
```C
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
```
EXTI和NVIC的时钟一般是常开的，不需要手动打开

#### GPIO配置
```C
	我自己写了一个超级函数，直接用
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
```
模式建议为浮空，上拉，下拉

## AFIO相关库函数及其配置
**先介绍一些相关的库函数**

```C
	GPIO_AFIODeInit(void);
```
这个函数用于复位AFIO

```C
	GPIO_EXTILineConfig(GPIO_PortSource , GPIO_PinSource);
```
这个函数用于配置AFIO，来选择我们想要进行中断判断的引脚
### 接下来是AFIO初始化代码流程

```C
	GPIO_EXTILineConfig(GPIO_PortSourceB,GPIO_PinSource14);
```
也就是我们选择了GPIOB的PB14的

## EXTI相关库函数及其配置
**先介绍一些相关的库函数**

```C
	EXTI_DeInit(void);
```
这个就是复位EXTI

```C
	EXTI_Init(EXTI_InitStructure);
```
这个就是初始化EXTI，和GPIO一样要建一个结构体

```C
	EXTI_StructInit(EXIT_InitStructure);
```
懒人函数，可以给"**给上一个函数用的结构体**"赋一个**初始值**

```C
	EXTI_GenerateSWIInterupt(EXTI_Line);
```
软件触发外部中断，用这个就可以让EXTI_Line触发一次外部中断

```C
	EXTI_GetFlagStatus(EXTI_Line);
```
一些事件发生时会在寄存器置一个**标志位 Flag**，这个函数就是看指定的标志位是否为1
Of course，这些事件包括中断事件，所以对应线路的寄存器会有一位置1

```C
	EXTI_ClearFlag(EXTI_Line);
```
清除标志位

```C
	EXTI_GetITStatus(EXTI_Line);
```
上面那两个是在正常函数( 主函数 )里访问标志位，这个就是在中断函数里访问

```C
	EXTI_ClearITPendingBit(EXTI_Line);
```

### 接下来是EXTI初始化代码流程

```C
	EXTI_InitTypeDef EXTI_InitStructure;
	EXTI_InitStructure.EXTI_Line = EXTI_Line14; //PB14
	EXTI_InitStructure.EXTI_LineCmd = ENABLE;
	EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
	EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
	EXTI_Init(&EXTI_InitStructure);
```

## NVIC相关库函数及配置
**先介绍一些相关的库函数**

```C
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup)
```
这个是用于中断分组的，实际上是去配置那个寄存器，我们在[[STM32 - 3 外部中断概述及EXTI中断概述]]里面提到过

```C
	NVIC_Init(NVIC_InitStructure);
```
和GPIO一样

```C
	NVIC_SetVectorTable(NVIC_VectTab , Offset);
```
设置向量表，当然这里我们无需配置

### 接下来是NVIC初始化代码流程

```C
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);

	NVIC_InitTypeDef NVIC_InitStructure;
	NVIC_InitStrucutre.NVIC_IRQChannel = EXTI15_10_IRQn; //PB14
	NVIC_InitStrucutre.NVIC_IRQChannelCmd = ENABLE;
	NVIC_InitStrucutre.NVIC_IRQChannelPreemptionPriority = 1;
	NVIC_InitStrucutre.NVIC_IRQChannelSubPriority = 1;
	NVIC_Init(&NVIC_InitStrucutre);
```

如果有多个中断事件，就要考虑优先级了

# 中断函数的书写
STM32里**中断函数**名字都是固定的
在**startup_stm32f10x_md.s**文件里定义了中断函数向量表，可以去那里查看对应的名字
我们这里使用的EXTI15_10_IRQHandler(void);

```C
	void EXTI15_10_IRQHandler(void){
	
	if(EXTI_GetITStatus(EXTI_Line14) == RESET) //用于判定是不是指定的线路
		return;

	EXTI_ClearITPendingBit(EXTI_Line14); //别忘了清除标志位
	...
	}
```

