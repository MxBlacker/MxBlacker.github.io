---
date: 2025-09-16
tag: "#嵌入式"
layout: post
title: STM32 - TIM输入捕获
---
#嵌入式 
# 输入捕获 IC Input Capture
**输入捕获**模式下，当通道输入引脚**出现指定电平跳变**时，当前CNT的值将被锁存到CCR中，可用于测量PWM波形的频率、占空比、脉冲间隔、电平持续时间等参数

每个高级定时器和通用定时器都拥有4个输入捕获通道
- 可配置为PWMI模式，同时**测量频率**和**占空比**
- 可配合主从触发模式，实现硬件全自动测量

**简单来说，输入捕获可以读取GPIO口的占空比和频率**，和示波器功能差不多

#### 和外部中断的区别
IC和EXTI都会在**出现指定电平跳变**时发生动作，但是**EXTI**是向CPU申请中断，**IC**是将**CNT**的值锁存在**CCR**中。

>[!attention] CNT的值因为TIM中断一直存在，是一直在增加的

# 频率测量
#### 测频法
**在闸门时间$T$内，对上升沿计次$N$**，这个测得就是$T$时间内的平均值了，要求信号频率高
$$f_x={N\over{T}}$$
#### 测周法
**两个上升沿内，以标准频率$f_c$计次$N$**，这个更加精确，要求信号频率低
$$f_x={f_c\over{N}}$$
**输入捕获 IC**就可以用于这种方法
两次上升沿，每次**锁一次CNT的值**，两次的**差值**就是N，而**标准频率**就是$f_{cnt}$
##### 中间频率
显然这两个各有优劣，我们需要找一个分界点
$${f_x}^2={fc\over{T}}\rightarrow{f_m=\sqrt{f_c\over{T}}}$$
高于$f_m$的算**高频**，低于算**低频**

# IC框图

![[STM32 TIM_IC框图.png]]

- **滤波器**的原理是在短时间内对**模拟信号**采样$N$次，如果均为低则输出低，均为高则输出高，可滤波
- 经过边沿检测器后输出**TI1F**信号，可以到CH2的路上去，**TI2F**的也可以到CH1的路上来，具体可以去看[[STM32 通用计时器.png]]
- **主从模式控制器**可以将信号映射到**TGRO**上，然后其他地方**TRGI**输入，从而实现某些操作，这里是实现CNT的清零操作，这样在第二个上升沿时，**CNT**锁入**CCR**后自动清零，方便计算

# PWMI流程图
![[STM32 PWMI流程图.png]]

我们说了**PWMI**可以测占空比，所以这里分了一路出去专门测**下降沿**，这样就可以测了。
上半部分和正常的测频率一样，但是是先读取CNT到CCR再**从模式触发Reset**

# IC初始化配置

1. 时钟开启，TIM开启，GPIO输入模式，上拉或者浮空
2. 时基单元配置
3. 配置**输入捕获单元**
4. 选择**从模式触发源**
5. 选择**触发后的操作**
6. 开始定时器

#### 基本函数介绍
```C
//OC有四个函数分别控制四个通道，而IC的初始化则都共用一个函数，初始化结构体里有可以选择的
TIM_ICInit(TIMx , TIM_ICInitStruct);

TIM_ICStructInit(&TIM_ICInitStruct);

TIM_SelectInputTrigger(TIMx , TIM_InputTriggerSource); //选择从模式触发源

TIM_SelectOutputTrigger(TIMx , TIM_TRGOSource); //主模式输出的触发源

TIM_SelectSlaveMode(TIMx , TIM_SlaveMode); //从模式选择

TIM_SetICxPrescaler(TIMx , TIM_ICPSC); //配置分频器，结构体也能配置

TIM_GetCapturex(TIMx); //获得CCR里锁的值
```

#### 配置
```C
RCC_APB1PeriphClockCmd(PCC_APB1Periph_TIM2 , ENABLE);
RCC_APB2PeriphClockCmd(PCC_APB2Periph_GPIOA , ENABLE);

AutoInitGPIO(...);
TIM2_Init(65536,72);

TIM_ICInitTypeDef TIM_ICInitStructure;
TIM_ICInitStructure.TIM_Channel = TIM_Channel_1; //1~4
TIM_ICInitStructure.TIM_ICFilter = 0xF;//滤波器 0x0~0xF
TIM_ICInitStructure.TIM_Polarity = TIM_ICPolarity_Rising;//_Falling  , _BothEdge
TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1; //分频器 1 2 4 8 
TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI; //直连通道 , IndirectTI交叉通道，就是跑到CH2去了
TIM_ICInit(TIM2 , &TIM_ICInitStructure);

TIM_SelectInputTrigger(TIM2 , TIM_TS_TI1FP1);
TIM_SelectSlaveMode(TIM2 , TIM_SlaveMode_Reset); //配置从模式

TIM_Cmd(TIM2 , ENABLE);
```

#### 频率计算
配置完成后，只要读取CCR的值就可以计算了

```C
int fx = (72000000 / Prescaler) / (TIM_GetCapture1(TIM2) + 1);
```

**+1**是为了去除正负1误差
#### 占空比计算
这个时候需要两个路同时计一个口了，我们再定义一个
```C
TIM_ICInitStructure.TIM_Channel = TIM_Channel_2; //1~4
TIM_ICInitStructure.TIM_ICFilter = 0xF;//滤波器 0x0~0xF
TIM_ICInitStructure.TIM_Polarity = TIM_ICPolarity_Falling;//_Falling  , _BothEdge
TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1; //分频器 1 2 4 8 
TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_IndirectTI; //直连通道 , IndirectTI交叉通道，就是跑到CH2去了
TIM_ICInit(TIM2 , &TIM_ICInitStructure);
```

当然，你也可以直接用这个函数

```C
TIM_PWMIConfig(TIM3 , TIM_ICInitStructure); //这个Structure就是第一次配置的Structure，也就省去再次定义的代码了
```

这时，Capture1获得的是**整个周期的CNT数**，Capture2是**从上升沿到下降沿的CNT数**，即：

```C
int Duty = (TIM_GetCapture2(TIM2) + 1) / (TIM_GetCapture1(TIM2) + 1); 
```

**+1**是为了去除正负1误差
