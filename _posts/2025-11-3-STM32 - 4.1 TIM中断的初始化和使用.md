---
date: 2025-09-16
tag: "#嵌入式"
layout: post
title: STM32 - TIM中断的初始化和使用
---
#嵌入式 
# RCC -> 选择模式 -> 时基单元 -> NVIC
**基本思路**
1. 打开**RCC**时钟，这里应该是APB1的，因为TIMxCLK都在APB1上
2. 选择时基单元的时钟源，我们选择**内部时钟模式**
3. 配置时基单元，通过一个结构体配置
4. 配置NVIC，即打开一个通道，并配置优先级
5. 使能计数器，不然计数器不会开

## TIM相关函数
```C
	TIM_DeInit(TIMx);
```
恢复配置

```C
	TIM_TimeBaseInit(TIMx,TimeBaseInitStruct);
```
用于**配置时基**单元，**后面定义的输入结构体**

```C
	TIM_TimeBaseStructInit(TimeBaseInitStruct);
```
用于给输入的结构体赋一个默认的值，懒人专用

```C
	TIM_Cmd(TIMx,NewState);
```
使能计时器

```C
	TIM_ITConfig(TIMx,TIM_IT,NewState);
```
使能中断输出信号，即使能**中断输出控制**

```C
	TIM_InternalClockConfig(TIMx);
	TIM_ITRxExternalClockConfig(TIMx,TIM_InputTriggerSource);
	TIM_TIxExternalClockConfig(TIMx,TIM_InputTriggerSource,TIM_ICPolarity,ICFilter);
	TIM_ETRClockMode1Config(TIMx,TIM_ExtTRGPrescaler,TIM_ExrTRGPolarity,ExTRGFilter);
	TIM_ETRClockMode2Config(TIMx,TIM_ExtTRGPrescaler,TIM_ExrTRGPolarity,ExTRGFilter);
	TIM_ETRConfig(TIMx,TIM_ExtTRGPrescaler,TIM_ExrTRGPolarity,ExTRGFilter);
```

这些都是用于更改输入模式的，**内部时钟**就**用内部输入模式**就行了，就是第一个

```C
	TIM_PrescalerConfig(TIMx,Prescaler,TIM_PSCReloadMode);
```

单独写预分频器的值的，**Prescaler**就是**预分频值**，**PSCReloadMode**是**写入模式**，也就是**APRE**

```C
	TIM_CounterModeConfig(TIMx,TIM_CounterMode);
```

改变Counter的**计数模式**，就是那些向上向下计数啥的

```C
	TIM_ARRPreloadConfig(TIMx,NewState);
```

是否预装TIMx_ARR，使能还是失能

**下面是一些有用的更改函数**

```C
	TIM_SetCounter(TIMx,Counter);
```

设置Counter的值

```C
	TIM_SetAutoreload(TIMx,Autoreload);
```

设置自动重装的值，即阈值

```C
	TIM_GetCounter(TIMx);
```

获得Counter的值

```C
	TIM_GetPrescaler(TIMx);
```

获得Prescaler的值

```C
	TIM_GetFlagStatus(TIMx,TIM_FLAG);
	TIM_ClearFlag(TIMX,TIM_FLAG);
	TIM_GetITStatus(TIMx,TIM_IT);
	TIM_ClearITPendingBit(TIMX,TIM_IT);	
```
清标志位的，和EXTI的差不多，不多解释

### TIM初始化代码流程
```C
RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIMx,ENABLE); //开启时钟
TIM_InternalClockConfig(TIMx); //可以不写，因为默认就是使用内部时钟
```

如果是**外部时钟**，这里以红外传感器为例

```C
	RCCAPB_PerpihClockCmd(RCC_APBPeriph_GPIOA,ENABLE);
	GPIO初始化略 (上拉输入)
	TIM_ETRClockMode2Config(TIM2,TIM_ExtTRGPSC_OFF,TIM_ExtTRGPolarity_NonInverted,0x00);
```

下面是TIM

```C
	TIM_TImeBaseInitTypeDef TIM_TimeBaseInitStructure;
	TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1; //分频数，可以是1,2,4
	TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up; //Counter模式
	TIM_TimeBaseInitStructure.TIM_Period = 10000 - 1; //这个和下一个都是0~65535的取值
	TIM_TimeBaseInitStructure.TIM_Prescaler = 7200 - 1; //参数要记得 - 1
	TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0; //仅高级计时器有用 
	TIM_TimeBaseInit(TIMx , &TIM_TimeBaseInitStructure);

	TIM_ITConfig(TIMx,TIM_IT_Update,ENABLE); //开启中断输出控制
```

下面是NVIC

```C
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);

	NVIC_InitTypeDef NVIC_InitStructure;
	NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn; //PB14
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
	NVIC_Init(&NVIC_InitStructure);
```

下面是最终使能

```C
	TIM_Cmd(TIMx,ENABLE);
```

### TIM中断函数

```C
	void TIMx_IRQHandler(void){
		if(TIM_GetITStatus(TIMx,TIM_IT_Update) == SET) TIM_ClearITPendingBit(TIMx,TIM_IT_Update);
		...
	}
```