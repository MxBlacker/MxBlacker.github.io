<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>C - 指针与地址 | 麦香包の超平坦世界</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="C - 指针与地址" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="地址 = 指针 变量的地址指的是变量所占字节的起始地址 *是将地址转化为存的变量的符号 &amp;是将变量转化为变量的地址的符号 在定义是，p被*转化后被定义为int变量，顺着思路理解，p就应当是指针" />
<meta property="og:description" content="地址 = 指针 变量的地址指的是变量所占字节的起始地址 *是将地址转化为存的变量的符号 &amp;是将变量转化为变量的地址的符号 在定义是，p被*转化后被定义为int变量，顺着思路理解，p就应当是指针" />
<link rel="canonical" href="http://localhost:4000/c/2025/09/16/C-%E5%9C%B0%E5%9D%80-&-%E6%8C%87%E9%92%88.html" />
<meta property="og:url" content="http://localhost:4000/c/2025/09/16/C-%E5%9C%B0%E5%9D%80-&-%E6%8C%87%E9%92%88.html" />
<meta property="og:site_name" content="麦香包の超平坦世界" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2025-09-16T00:00:00+08:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="C - 指针与地址" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-09-16T00:00:00+08:00","datePublished":"2025-09-16T00:00:00+08:00","description":"地址 = 指针 变量的地址指的是变量所占字节的起始地址 *是将地址转化为存的变量的符号 &amp;是将变量转化为变量的地址的符号 在定义是，p被*转化后被定义为int变量，顺着思路理解，p就应当是指针","headline":"C - 指针与地址","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/c/2025/09/16/C-%E5%9C%B0%E5%9D%80-&-%E6%8C%87%E9%92%88.html"},"url":"http://localhost:4000/c/2025/09/16/C-%E5%9C%B0%E5%9D%80-&-%E6%8C%87%E9%92%88.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="麦香包の超平坦世界" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">麦香包の超平坦世界</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">C - 指针与地址</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2025-09-16T00:00:00+08:00" itemprop="datePublished">Sep 16, 2025
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p><strong>地址 = 指针</strong>
变量的地址指的是变量所占字节的起始地址
*是将地址转化为存的变量的符号 &amp;是将变量转化为变量的地址的符号
在定义是，<strong>p被*转化后被定义为int变量</strong>，顺着思路理解，<strong>p就应当是指针</strong></p>

<h1 id="地址的应用">地址的应用</h1>

<p>用int * 来定义一个专门放某个变量的指针的变量</p>

<pre><code class="language-C">	int * p1 = &amp;a; //定义一个指针变量 , 叫p1 , 存&amp;a (这里的*和int绑定，不和p1绑定)
	int * p2 = &amp;b;
	*p2 = *p1 + *p2; //等价于 b = a + b (这里的*就作用于p身上了)
</code></pre>

<p>* 后面跟指针，整个的意思就是指针所指向的变量，也代表指针指向的变量
==在p++后，他的变量值会直接+4 ( 结构体似乎是直接加更多，总之++就能遍历数组了)，因为一个地址默认4bit==</p>

<h1 id="数组的地址">数组的地址</h1>

<pre><code class="language-C">	arr[10] = {};
	*arr = 【arr[0]的地址】;
	*arr+1 = 【arr[1]的地址】;
	
	//所以在赋值时也可以这样
	
	scanf("%d",arr+i) //arr没有取地址的时候默认取地址
	for(p = arr;...) //p = arr相当于p现在存储的是arr[0]的地址
		sum += *p;
</code></pre>

<p>指针在一维数组比较飞舞
但是你要知道二维数组的存储方式和其表示方式不一样！二维数组的存取方式是一维的！
另外，可以尝试对二维数组的本质进行理解，实际上就是数组套数组，数组也算一个元素
==以及，都别忘了在取值的时候-1!==</p>

<pre><code class="language-C">	arr[10][10] = {};
</code></pre>

<blockquote>
  <p>[!attention]
注意，二维数组的数组名和一位数组不一样，不直接表示其开始地址
arr表示的是<code class="language-plaintext highlighter-rouge">arr[0]</code>的地址，而此时<code class="language-plaintext highlighter-rouge">arr[0]</code>是一个数组，而我们要的是<code class="language-plaintext highlighter-rouge">arr[0]</code>的第一个元素的地址
所以,用<code class="language-plaintext highlighter-rouge">*arr</code>表示<code class="language-plaintext highlighter-rouge">arr[0]</code></p>
</blockquote>

<pre><code class="language-C">	int * p = arr[0];
	int * p = *arr;
</code></pre>

<blockquote>
  <p>[!attention]
又要注意，此时arr中每一行都为一个数组，其第n行的数组名为<code class="language-plaintext highlighter-rouge">arr[n-1]</code>，名称作用效果和一维一样
例如<code class="language-plaintext highlighter-rouge">arr[0]</code>就代表<code class="language-plaintext highlighter-rouge">arr[0][0]</code>,<code class="language-plaintext highlighter-rouge">(arr[1]+1)</code>就代表<code class="language-plaintext highlighter-rouge">arr[1][1]</code>
接下来是三种指针的表示方法</p>
</blockquote>

<pre><code class="language-C">	*(arr + i)+j / *(*(arr + i)+j) 表示该地址元素的值
	//解析一下加括号的必要性，arr+i表示的是第i-1行的数组，加了*后就指向了这个数组，等价于arr[i-1]，这也就和下面一种表示方式一样了
	
	arr[i]+j //前面提到过arr[i]在二维数组中表示其中一个作为元素的数组的名字,所以这里的arr[i]实际为arr[i]的地址
	
	&amp;a[i][j] //最简单的方法
</code></pre>

<p>这里还是进行一下区分，两种指针：</p>

<pre><code class="language-C">	int (*p[5]) //这是定义一个数组，其中每一个值都应当存指针 也可写为int * p[5]
	//指针数组
	int (*p)[5] //这是一个数组指针(一个变量！)，其指向了一个长度为5的数组(int)
	//数组指针——即指向数组的指针！
</code></pre>

<p>也就是说，p实际上还是一个函数名，直接在他后面跟[5]就是创建数组
在()外面跟[5]就是指定类型了</p>

<h1 id="实际运用1">实际运用#1</h1>

<pre><code class="language-C">	int sum_two_dimensional_array(int arr[][3],int * p,int row){
		int * p = *arr; //这里*arr表示arr[0]，而arr[0]是一个数组，所以表示为这个数组开始的地址，也就是这个二维数组开始的地址
		int sum = 0;
		for(;p &lt;= *(arr+row-1)+length-1;p++)//*(arr+row-1)+length-1表示最后元素的地址
			sum += *p;
		return sum;
	}
	int main(){
		arr[3][3]={};
		sum_two_dimensional_array(arr,...) 
	}
</code></pre>
<p>会发现，如果你想要往函数里导一个多个维度都未定义长度的数组，编译器会报错，提示你”只有第一个维度才能不限长度的输入函数”，这就是为什么我函数定义里写的是”arr[][3]”</p>

<h1 id="实际运用11">实际运用#1.1</h1>

<pre><code class="language-C">	//为了解决实际运用#1中的煞笔问题（多个未被定义长度的数组导入函数），指针就派上用场了
	//真不知道那个数组指针有什么用= =
	int sum_two_dimensional_array(int * p,int row,int length){
		int sum = 0;
		for(int i=0;i &lt; row * length;i++){
			sum += *p;
			p++;
		}
		return sum;
	}
	int main(){
		int arr[n][m] = {...};
		sum = sum_two_dimensional_array(*arr,n.m) //此时p导入的就是arr[0][0]的地址
	}
</code></pre>

<p>这样就可以完美解决，我暂时想不到这个方法的劣势在哪里，简直完美！</p>

<pre><code class="language-C">	//说句题外的，更高维度的数组用这个方法就不好整了，可以这样
	int function(int axis1,int axis2, ... ,int arr[axis1][axis2][...]){}
	//先定义每个维度的长度，再定义数组
</code></pre>

<p>其实写到这里了也可以顺便讲一下另外两个指针定义</p>

<h1 id="实际运用2">实际运用#2</h1>

<pre><code class="language-C">	int sum_of_array(int *p,int length){
		int sum = 0;
		int *p_temp = p; //用于记录数组开头的地址
		for(;p &lt; p_temp + length;p++) sum += *p;
		return sum;
		//这一块也可以向我上面那样定义一个i，这样就可以直接用length做结束判定，不用另设变量
	}
	int main(){
		arr[len]={...}
		total = sum_of_array(arr,len);//直接输数组名，即数组的地址
	}
</code></pre>

<h1 id="实际运用21">实际运用#2.1</h1>

<pre><code class="language-C">	int sum_of_array(int arr[],int length){...}
	int main(){
		arr[len]={...};
		total = sum_of_array(arr,len);
		//这里的arr传的直接是地址，但somehow,虽然函数明确规定需要输入一个一维数组，但它还是知道我们想传的是arr,以后有思路了来补
	}
</code></pre>
<h1 id="指针函数">指针函数</h1>

<pre><code class="language-C">	//和数组指针和指针数组类似
	int * p(int a,int b...){}
	//指针函数，如你所见，这是个函数，只不过返回值是一个指针
</code></pre>
<h1 id="例1">例1</h1>

<p>一个指针函数返回一个指针，赋值到指针变量上，再把指针变量所指的变量输出，很合理吧</p>

<pre><code class="language-C">	int *max(int a, int b) { 
	    if (a &gt; b) return &amp;a;
	    else return &amp;b;
	}
	int main() {
	    int a, b;
	    scanf("%d%d", &amp;a, &amp;b);
	    int *num = max(a, b);
	    printf("%d",*num);
	    return 0;
	}
</code></pre>
<p>出来之后发现是错的！num的值为0！为什么呢，在我问了deepseek后，找到了我一直以来的思维误区</p>
<h1 id="例11">例1.1</h1>
<p>在将变量输入函数后，==函数实际上是将这些变量的值赋值到临时变量上，再进行计算的==</p>

<p>也就是说，例1之所以错，是因为在将我输入的a,b输入变量后，==C语言又给临时变量a和临时变量b开了两个新空间，把值赋值了进去（要区分a和临时a）==，而我们返回的是这个临时a的地址</p>

<p>而在函数结束的一瞬间，这两个临时变量也就消失了，指针也就成了悬空指针(=0)，所以返回一个临时变量地址是没有意义的。因为他会在return前的一瞬间把临时变量清理掉，也就不知道指针指的是哪里了。</p>

<p>所以，我们需要返回的值本身就应该是个地址，这样它的地址就不会在return前一秒变为0了</p>

<pre><code class="language-C">	int *max(int *a, int *b) { //定义两个指针
	    if (*a &gt; *b) return a; //返回指针
	    else return b;
	}
	int main() {
	    int a, b;
	    scanf("%d%d", &amp;a, &amp;b);
	    int *num = max(&amp;a, &amp;b);
	    printf("%d", *num);
	    return 0;
	}
</code></pre>

<h1 id="例2-课程">例2 (课程)</h1>

<p>给到了一个swap函数的定义，一般来说我会这样写</p>

<pre><code class="language-C">	int a,b;
	void swap(){
		int t=a;
		a=b;
		b=t;
	}
	int main(){
		scanf("%d%d",&amp;a,&amp;b);
		swap(a,b);
	}
</code></pre>

<p>这样就避免了函数无法直接对外部变量修改的问题，但毫无疑问，这有很多弊端。
所以指针就排上用场了</p>

<pre><code class="language-C">	void swap(int *x,int *y){
		int t=*x;
		*x=*y;
		*y=t;
	}
	int main(){
		int a,b;
		scanf("%d%d",&amp;a,&amp;b);
		swap(&amp;a,&amp;b);
	}
</code></pre>
<p>这样，我们在调用函数的时候输入的是外部变量的坐标，虽然函数建立的是临时变量，但这个临时指针变量指向的依然是外面的变量的地址，所以可以直接对外部变量进行修改。</p>

<p>这也就是为啥像swap,sort那些头文件的函数定义里全是*的原因
[[C - 4 字符串#Strcat]]里我举了个例子，可以看看</p>

<h1 id="函数指针">函数指针</h1>

<p>函数指针是一个指针，但是指向的是函数</p>

<pre><code class="language-C">	int max(int a,int b){...}
	int (*p)(int ,int ) = max;
</code></pre>

<p>运用例子见[[C - 0 常见函数#include <stdlib.h>]]</stdlib.h></p>

<h1 id="不同类型的指针">不同类型的指针</h1>

<p>[[C - 4 字符串#字符指针]][[C - 6 结构体#结构体指针]]
指针要指向什么类型的变量，你就得用什么类型来定义指针</p>

<h1 id="int-a-和-int-a-有什么区别">int a[] 和 int *a 有什么区别？</h1>

<p>int a[]中的 a 是一个指针常量！
他大概是这样定义的 : const int * a;</p>

<p>int * a 是一个指针<strong>变量</strong>，虽然他们确实都可以用来存数组，但是显然，和我上面提到过的一样，下面这种方法并不安全</p>

<p>![[C - 5.png]]</p>

  </div><a class="u-url" href="/c/2025/09/16/C-%E5%9C%B0%E5%9D%80-&-%E6%8C%87%E9%92%88.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">麦香包の超平坦世界</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">麦香包の超平坦世界</li><li><a class="u-email" href="mailto:sweetwheatbread@gmail.com">sweetwheatbread@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/MxBlacker"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">MxBlacker</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p></p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
