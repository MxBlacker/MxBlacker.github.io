<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2025-11-20T22:33:09+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">麦香包の超平坦世界</title><subtitle></subtitle><entry><title type="html">幸会！</title><link href="http://localhost:4000/jekyll/update/2025/11/20/WELCOME.html" rel="alternate" type="text/html" title="幸会！" /><published>2025-11-20T21:28:14+08:00</published><updated>2025-11-20T21:28:14+08:00</updated><id>http://localhost:4000/jekyll/update/2025/11/20/WELCOME</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2025/11/20/WELCOME.html"><![CDATA[<p>欢迎来到麦香包的超平坦世界！这是使用Jekyll搭建的静态网站，专门上传麦香包的笔记。
用Jekyll很大一部分原因是因为懒，赫赫。然后就是Jekyll能够直接识别markdown文件，这就很好，所以它能很好的构建一个静态网站，显然我传笔记是不需要动态网站的。</p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[欢迎来到麦香包的超平坦世界！这是使用Jekyll搭建的静态网站，专门上传麦香包的笔记。 用Jekyll很大一部分原因是因为懒，赫赫。然后就是Jekyll能够直接识别markdown文件，这就很好，所以它能很好的构建一个静态网站，显然我传笔记是不需要动态网站的。]]></summary></entry><entry><title type="html">C - 指针与地址</title><link href="http://localhost:4000/c/2025/09/16/C-%E5%9C%B0%E5%9D%80-&-%E6%8C%87%E9%92%88.html" rel="alternate" type="text/html" title="C - 指针与地址" /><published>2025-09-16T00:00:00+08:00</published><updated>2025-09-16T00:00:00+08:00</updated><id>http://localhost:4000/c/2025/09/16/C%20-%20%E5%9C%B0%E5%9D%80%20&amp;%20%E6%8C%87%E9%92%88</id><content type="html" xml:base="http://localhost:4000/c/2025/09/16/C-%E5%9C%B0%E5%9D%80-&amp;-%E6%8C%87%E9%92%88.html"><![CDATA[<p><strong>地址 = 指针</strong>
变量的地址指的是变量所占字节的起始地址
*是将地址转化为存的变量的符号 &amp;是将变量转化为变量的地址的符号
在定义是，<strong>p被*转化后被定义为int变量</strong>，顺着思路理解，<strong>p就应当是指针</strong></p>

<h1 id="地址的应用">地址的应用</h1>

<p>用int * 来定义一个专门放某个变量的指针的变量</p>

<pre><code class="language-C">	int * p1 = &amp;a; //定义一个指针变量 , 叫p1 , 存&amp;a (这里的*和int绑定，不和p1绑定)
	int * p2 = &amp;b;
	*p2 = *p1 + *p2; //等价于 b = a + b (这里的*就作用于p身上了)
</code></pre>

<p>* 后面跟指针，整个的意思就是指针所指向的变量，也代表指针指向的变量
==在p++后，他的变量值会直接+4 ( 结构体似乎是直接加更多，总之++就能遍历数组了)，因为一个地址默认4bit==</p>

<h1 id="数组的地址">数组的地址</h1>

<pre><code class="language-C">	arr[10] = {};
	*arr = 【arr[0]的地址】;
	*arr+1 = 【arr[1]的地址】;
	
	//所以在赋值时也可以这样
	
	scanf("%d",arr+i) //arr没有取地址的时候默认取地址
	for(p = arr;...) //p = arr相当于p现在存储的是arr[0]的地址
		sum += *p;
</code></pre>

<p>指针在一维数组比较飞舞
但是你要知道二维数组的存储方式和其表示方式不一样！二维数组的存取方式是一维的！
另外，可以尝试对二维数组的本质进行理解，实际上就是数组套数组，数组也算一个元素
==以及，都别忘了在取值的时候-1!==</p>

<pre><code class="language-C">	arr[10][10] = {};
</code></pre>

<blockquote>
  <p>[!attention]
注意，二维数组的数组名和一位数组不一样，不直接表示其开始地址
arr表示的是<code class="language-plaintext highlighter-rouge">arr[0]</code>的地址，而此时<code class="language-plaintext highlighter-rouge">arr[0]</code>是一个数组，而我们要的是<code class="language-plaintext highlighter-rouge">arr[0]</code>的第一个元素的地址
所以,用<code class="language-plaintext highlighter-rouge">*arr</code>表示<code class="language-plaintext highlighter-rouge">arr[0]</code></p>
</blockquote>

<pre><code class="language-C">	int * p = arr[0];
	int * p = *arr;
</code></pre>

<blockquote>
  <p>[!attention]
又要注意，此时arr中每一行都为一个数组，其第n行的数组名为<code class="language-plaintext highlighter-rouge">arr[n-1]</code>，名称作用效果和一维一样
例如<code class="language-plaintext highlighter-rouge">arr[0]</code>就代表<code class="language-plaintext highlighter-rouge">arr[0][0]</code>,<code class="language-plaintext highlighter-rouge">(arr[1]+1)</code>就代表<code class="language-plaintext highlighter-rouge">arr[1][1]</code>
接下来是三种指针的表示方法</p>
</blockquote>

<pre><code class="language-C">	*(arr + i)+j / *(*(arr + i)+j) 表示该地址元素的值
	//解析一下加括号的必要性，arr+i表示的是第i-1行的数组，加了*后就指向了这个数组，等价于arr[i-1]，这也就和下面一种表示方式一样了
	
	arr[i]+j //前面提到过arr[i]在二维数组中表示其中一个作为元素的数组的名字,所以这里的arr[i]实际为arr[i]的地址
	
	&amp;a[i][j] //最简单的方法
</code></pre>

<p>这里还是进行一下区分，两种指针：</p>

<pre><code class="language-C">	int (*p[5]) //这是定义一个数组，其中每一个值都应当存指针 也可写为int * p[5]
	//指针数组
	int (*p)[5] //这是一个数组指针(一个变量！)，其指向了一个长度为5的数组(int)
	//数组指针——即指向数组的指针！
</code></pre>

<p>也就是说，p实际上还是一个函数名，直接在他后面跟[5]就是创建数组
在()外面跟[5]就是指定类型了</p>

<h1 id="实际运用1">实际运用#1</h1>

<pre><code class="language-C">	int sum_two_dimensional_array(int arr[][3],int * p,int row){
		int * p = *arr; //这里*arr表示arr[0]，而arr[0]是一个数组，所以表示为这个数组开始的地址，也就是这个二维数组开始的地址
		int sum = 0;
		for(;p &lt;= *(arr+row-1)+length-1;p++)//*(arr+row-1)+length-1表示最后元素的地址
			sum += *p;
		return sum;
	}
	int main(){
		arr[3][3]={};
		sum_two_dimensional_array(arr,...) 
	}
</code></pre>
<p>会发现，如果你想要往函数里导一个多个维度都未定义长度的数组，编译器会报错，提示你”只有第一个维度才能不限长度的输入函数”，这就是为什么我函数定义里写的是”arr[][3]”</p>

<h1 id="实际运用11">实际运用#1.1</h1>

<pre><code class="language-C">	//为了解决实际运用#1中的煞笔问题（多个未被定义长度的数组导入函数），指针就派上用场了
	//真不知道那个数组指针有什么用= =
	int sum_two_dimensional_array(int * p,int row,int length){
		int sum = 0;
		for(int i=0;i &lt; row * length;i++){
			sum += *p;
			p++;
		}
		return sum;
	}
	int main(){
		int arr[n][m] = {...};
		sum = sum_two_dimensional_array(*arr,n.m) //此时p导入的就是arr[0][0]的地址
	}
</code></pre>

<p>这样就可以完美解决，我暂时想不到这个方法的劣势在哪里，简直完美！</p>

<pre><code class="language-C">	//说句题外的，更高维度的数组用这个方法就不好整了，可以这样
	int function(int axis1,int axis2, ... ,int arr[axis1][axis2][...]){}
	//先定义每个维度的长度，再定义数组
</code></pre>

<p>其实写到这里了也可以顺便讲一下另外两个指针定义</p>

<h1 id="实际运用2">实际运用#2</h1>

<pre><code class="language-C">	int sum_of_array(int *p,int length){
		int sum = 0;
		int *p_temp = p; //用于记录数组开头的地址
		for(;p &lt; p_temp + length;p++) sum += *p;
		return sum;
		//这一块也可以向我上面那样定义一个i，这样就可以直接用length做结束判定，不用另设变量
	}
	int main(){
		arr[len]={...}
		total = sum_of_array(arr,len);//直接输数组名，即数组的地址
	}
</code></pre>

<h1 id="实际运用21">实际运用#2.1</h1>

<pre><code class="language-C">	int sum_of_array(int arr[],int length){...}
	int main(){
		arr[len]={...};
		total = sum_of_array(arr,len);
		//这里的arr传的直接是地址，但somehow,虽然函数明确规定需要输入一个一维数组，但它还是知道我们想传的是arr,以后有思路了来补
	}
</code></pre>
<h1 id="指针函数">指针函数</h1>

<pre><code class="language-C">	//和数组指针和指针数组类似
	int * p(int a,int b...){}
	//指针函数，如你所见，这是个函数，只不过返回值是一个指针
</code></pre>
<h1 id="例1">例1</h1>

<p>一个指针函数返回一个指针，赋值到指针变量上，再把指针变量所指的变量输出，很合理吧</p>

<pre><code class="language-C">	int *max(int a, int b) { 
	    if (a &gt; b) return &amp;a;
	    else return &amp;b;
	}
	int main() {
	    int a, b;
	    scanf("%d%d", &amp;a, &amp;b);
	    int *num = max(a, b);
	    printf("%d",*num);
	    return 0;
	}
</code></pre>
<p>出来之后发现是错的！num的值为0！为什么呢，在我问了deepseek后，找到了我一直以来的思维误区</p>
<h1 id="例11">例1.1</h1>
<p>在将变量输入函数后，==函数实际上是将这些变量的值赋值到临时变量上，再进行计算的==</p>

<p>也就是说，例1之所以错，是因为在将我输入的a,b输入变量后，==C语言又给临时变量a和临时变量b开了两个新空间，把值赋值了进去（要区分a和临时a）==，而我们返回的是这个临时a的地址</p>

<p>而在函数结束的一瞬间，这两个临时变量也就消失了，指针也就成了悬空指针(=0)，所以返回一个临时变量地址是没有意义的。因为他会在return前的一瞬间把临时变量清理掉，也就不知道指针指的是哪里了。</p>

<p>所以，我们需要返回的值本身就应该是个地址，这样它的地址就不会在return前一秒变为0了</p>

<pre><code class="language-C">	int *max(int *a, int *b) { //定义两个指针
	    if (*a &gt; *b) return a; //返回指针
	    else return b;
	}
	int main() {
	    int a, b;
	    scanf("%d%d", &amp;a, &amp;b);
	    int *num = max(&amp;a, &amp;b);
	    printf("%d", *num);
	    return 0;
	}
</code></pre>

<h1 id="例2-课程">例2 (课程)</h1>

<p>给到了一个swap函数的定义，一般来说我会这样写</p>

<pre><code class="language-C">	int a,b;
	void swap(){
		int t=a;
		a=b;
		b=t;
	}
	int main(){
		scanf("%d%d",&amp;a,&amp;b);
		swap(a,b);
	}
</code></pre>

<p>这样就避免了函数无法直接对外部变量修改的问题，但毫无疑问，这有很多弊端。
所以指针就排上用场了</p>

<pre><code class="language-C">	void swap(int *x,int *y){
		int t=*x;
		*x=*y;
		*y=t;
	}
	int main(){
		int a,b;
		scanf("%d%d",&amp;a,&amp;b);
		swap(&amp;a,&amp;b);
	}
</code></pre>
<p>这样，我们在调用函数的时候输入的是外部变量的坐标，虽然函数建立的是临时变量，但这个临时指针变量指向的依然是外面的变量的地址，所以可以直接对外部变量进行修改。</p>

<p>这也就是为啥像swap,sort那些头文件的函数定义里全是*的原因
[[C - 4 字符串#Strcat]]里我举了个例子，可以看看</p>

<h1 id="函数指针">函数指针</h1>

<p>函数指针是一个指针，但是指向的是函数</p>

<pre><code class="language-C">	int max(int a,int b){...}
	int (*p)(int ,int ) = max;
</code></pre>

<p>运用例子见[[C - 0 常见函数#include <stdlib.h>]]</stdlib.h></p>

<h1 id="不同类型的指针">不同类型的指针</h1>

<p>[[C - 4 字符串#字符指针]][[C - 6 结构体#结构体指针]]
指针要指向什么类型的变量，你就得用什么类型来定义指针</p>

<h1 id="int-a-和-int-a-有什么区别">int a[] 和 int *a 有什么区别？</h1>

<p>int a[]中的 a 是一个指针常量！
他大概是这样定义的 : const int * a;</p>

<p>int * a 是一个指针<strong>变量</strong>，虽然他们确实都可以用来存数组，但是显然，和我上面提到过的一样，下面这种方法并不安全</p>

<p>![[C - 5.png]]</p>]]></content><author><name></name></author><category term="C" /><summary type="html"><![CDATA[地址 = 指针 变量的地址指的是变量所占字节的起始地址 *是将地址转化为存的变量的符号 &amp;是将变量转化为变量的地址的符号 在定义是，p被*转化后被定义为int变量，顺着思路理解，p就应当是指针]]></summary></entry></feed>